var store = [{
        "title": "[C++] BOJ_1463 1로 만들기",
        "excerpt":"문제: 백준 1463 (c++) 풀이과정 우선 이 문제를 처음 봤을 때 이미 dp라는 것을 알고 접근했다. 그러나 아무리 생각해 봐도 도저히 10이 있을 때 바로 2로 나누는 것이 아닌 1을 먼저 뺌으로써 10이 1로 되기까지의 연산 횟수의 최솟값을 구하는 방법을 생각하는 데 어려움을 겪었다. 구글링을 통해 정보를 얻고 난 후에야...","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/1463/",
        "teaser": null
      },{
        "title": "[C++] BOJ_2579 계단 오르기",
        "excerpt":"문제: 백준 2579 (c++) 풀이과정 이 문제는 조건이 조금 까다롭다고 느낄 수 있다. 계단이 네 개가 있다고 가정을 했을 때, 계단 1, 2는 무조건 한 칸씩 가는 것이 최댓값을 구할 때 도움이 된다. 따라서 dp 배열에 먼저 값을 지정해 주었고, 세 번째 계단은 애초에 문제 조건에 연속 세 계단을 밟을...","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/2579/",
        "teaser": null
      },{
        "title": "[C++] BOJ_9095 1, 2, 3 더하기 ",
        "excerpt":"문제: 백준 9095 (c++) 풀이과정 문제를 조금 나눠서 생각해 보면, 예시로 숫자 4가 있다고 했을 때 dp 점화식을 찾는 것이기 때문에 숫자 1, 2, 3, 4의 순서로 생각해 보면 편하다. 숫자가 1일 경우에는 1(가지 방법) 숫자가 2일 경우에는 2 (1+1, 2) 숫자가 3일 경우에는 4 (1+1, 1+2, 2+1, 3) 이다....","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/9095/",
        "teaser": null
      },{
        "title": "[C++] BOJ_1149  RGB 거리",
        "excerpt":"문제: 백준 1149 (c++) 풀이과정 처음 조건만 잘 본다면 생각보다 쉽게 점화식을 찾아낼 수 있다. 집에 색을 칠하는 조건이 총 세 가지가 나와 있는데 결국 각 집이 앞뒤 색상이 달라야 한다는 말이다. 그렇기에 처음 시작을 세 가지 경우로 나누는 것으로 접근하면 된다. 0, 1, 2가 빨강, 초록, 파랑이기에 min 함수를...","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/1149/",
        "teaser": null
      }]
