var store = [{
        "title": "[C++] BOJ_1463 1로 만들기",
        "excerpt":"문제: 백준 1463 (c++) 풀이과정 우선 이 문제를 처음 봤을 때 이미 dp라는 것을 알고 접근했다. 그러나 아무리 생각해 봐도 도저히 10이 있을 때 바로 2로 나누는 것이 아닌 1을 먼저 뺌으로써 10이 1로 되기까지의 연산 횟수의 최솟값을 구하는 방법을 생각하는 데 어려움을 겪었다. 구글링을 통해 정보를 얻고 난 후에야...","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/1463/",
        "teaser": null
      },{
        "title": "[C++] BOJ_2579 계단 오르기",
        "excerpt":"문제: 백준 2579 (c++) 풀이과정 이 문제는 조건이 조금 까다롭다고 느낄 수 있다. 계단이 네 개가 있다고 가정을 했을 때, 계단 1, 2는 무조건 한 칸씩 가는 것이 최댓값을 구할 때 도움이 된다. 따라서 dp 배열에 먼저 값을 지정해 주었고, 세 번째 계단은 애초에 문제 조건에 연속 세 계단을 밟을...","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/2579/",
        "teaser": null
      },{
        "title": "[C++] BOJ_9095 1, 2, 3 더하기 ",
        "excerpt":"문제: 백준 9095 (c++) 풀이과정 문제를 조금 나눠서 생각해 보면, 예시로 숫자 4가 있다고 했을 때 dp 점화식을 찾는 것이기 때문에 숫자 1, 2, 3, 4의 순서로 생각해 보면 편하다. 숫자가 1일 경우에는 1(가지 방법) 숫자가 2일 경우에는 2 (1+1, 2) 숫자가 3일 경우에는 4 (1+1, 1+2, 2+1, 3) 이다....","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/9095/",
        "teaser": null
      },{
        "title": "[C++] BOJ_1149  RGB 거리",
        "excerpt":"문제: 백준 1149 (c++) 풀이과정 처음 조건만 잘 본다면 생각보다 쉽게 점화식을 찾아낼 수 있다. 집에 색을 칠하는 조건이 총 세 가지가 나와 있는데 결국 각 집이 앞뒤 색상이 달라야 한다는 말이다. 그렇기에 처음 시작을 세 가지 경우로 나누는 것으로 접근하면 된다. 0, 1, 2가 빨강, 초록, 파랑이기에 min 함수를...","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/1149/",
        "teaser": null
      },{
        "title": "[C++] BOJ_1932 정수 삼각형",
        "excerpt":"문제: 백준 1932 (c++) 풀이과정 문제에 나온 삼각형을 조건에 맞게 보면 아래층은 위층의 대각선 왼쪽 또는 대각선 오른쪽 숫자를 선택할 수 있는데, 배열로 생각하여 정리해 보면, 현재가 i 층일 때 dp[i-1][j] 또는 dp[i-1][j-1]의 숫자를 선택할 수 있다는 것이다. 이 문제는 최댓값을 구하는 문제이기에 제일 위 쪽의 두 개의 층은 직접...","categories": ["algorithm"],
        "tags": ["dp"],
        "url": "/algorithm/1932/",
        "teaser": null
      },{
        "title": "K-Nearest Neighbors (K-최근접 이웃 알고리즘)",
        "excerpt":"K-Nearest Neighbors (K-NN, K-최근접 이웃 알고리즘) 머신러닝에서 지도 학습의 한 종류로 거리 기반 분류 분석 모델로 새로운 데이터가 주어졌을 때, 이 데이터에 대한 답을 예측하는 것이라고 할 수 있다. 데이터 간의 거리 측정에 의존하고 유클리디안 거리 계산법을 사용하여 주변의 가까운 데이터 K 개를 지정해서 다수를 차지하는 것을 정답으로 한다. -&gt; 그렇기에 K의...","categories": ["ML"],
        "tags": [],
        "url": "/ml/KNN/",
        "teaser": null
      },{
        "title": "[C++] BOJ_2667 단지 번호 붙이기",
        "excerpt":"문제: 백준 2667 (c++) 풀이과정 이 문제는 dfs 또는 bfs로 풀 수 있는데 아래의 코드는 dfs로 푼 코드이다. 주어진 배열을 탐색한다는 느낌으로 접근하면 쉬울 것이다. maze 문제 (미로 탐색 문제)와 비슷하다. 코드를 분리하여 보면, int n ; int cnt1 = 0 ; int cnt2 = 0 ; int board[26][26] ;...","categories": ["algorithm"],
        "tags": ["dfs"],
        "url": "/algorithm/2667/",
        "teaser": null
      }]
